import matplotlib.pyplot as plt
import numpy as np
import math as m
from modules import BPSKGen
from modules import SigUtil
from modules import FilterGen
from modules import FiltUtil

# useful objects
PI = np.pi
s = SigUtil.SigUtil()
b = BPSKGen.BPSKGen()
f1 = FilterGen.FilterGen()
f2 = FilterGen.FilterGen()
ft = FiltUtil.FiltUtil()

# plotting control
PLT_SIGNAL          = 1
PLT_DS_PADDED       = 0
PLT_DS_PADDED_CONV  = 0
PLT_DS_CONV_KERNEL  = 0
PLT_DS_TIME         = 1
PLT_STD_FREQ        = 1
PLT_RECON           = 1
PLT_RANGE           = 10000

#######################
### Signal Creation ###
#######################

## custom params
f0 = 100e6
BW = 25e6
T0 = 1/ f0
N_paths = 8                 ## number of paths/ number of 'generators'
chip_rate = 1.024e6
chip_number = 256
prn_fac = 5
boc_fac = 0
boc_phase = 0

## digitals system down-sampled-convolution example
# digitals params
sample_clk = 307.2e6
sample_rate = sample_clk * N_paths

# digitals bpsk signal
d_bpsk, d_bpsk_t = b.digitals_bpsk_mod(sample_clk,f0,N_paths,chip_rate,chip_number,prn_fac,boc_fac,boc_phase)
center_freq = b.digitals_center_freq
bpsk_time_range = chip_number * b.digitals_f0_prn_mult * 1/ f0

Ns = len(d_bpsk)
Nds = int(Ns/N_paths)                       ## samples in 1/N_paths broken waveform

# create bpfilter from filter object
Ns_dk = 31                                 ## number of samples for down-sampled (must be odd)
Ns_fk = Ns_dk * N_paths + 1                 ## number of samples for full kernel  (forced to be odd)
kernel, kernel_time = f1.digitals_bp_filt(center_freq,BW,Ns_fk,sample_rate)

Nk = len(kernel)                            ## samples in kernel
kernel_time_range = 2 * f1.Nl * (1/center_freq) * len(kernel)/f1.M_b

print("signal len: ",len(d_bpsk), "kernel len: ",len(kernel))
print("center_freq: ",center_freq, "bpsk time range: ",bpsk_time_range)

## determine length of convolution signals + time arguments
# length of convolution between signal and kernel
conv_len = Ns + Nk - 1
conv_time_range = bpsk_time_range + kernel_time_range

# convolve signals together
conv_time = np.linspace(0,conv_time_range,conv_len)
conv = np.convolve(d_bpsk,kernel)

########################################################
### Down sampled signal + kernel (padded with zeros) ###
########################################################

N_paths_ds = 4
# down-sampled-padded signals
s_dp = []
for i in range(N_paths_ds): 
  s_dp.append(list(np.zeros(Ns)))

# populate down-sampled signal arrays
for path in range(N_paths_ds):
  for idx in range(len(d_bpsk)):
    if(idx % N_paths_ds == path): s_dp[path][idx] = d_bpsk[idx]

# convolve down-sampled signals with kernel
s_dp_conv = []
for path in range(N_paths_ds):
  s_dp_conv.append(list(np.convolve(s_dp[path],kernel)))

# rebuild convolution output array
sb_conv = np.zeros(conv_len)
for path in range(N_paths_ds):
  sb_conv = sb_conv + np.array(s_dp_conv[path])

print("conv_len= ",conv_len,"sb_conv len=",len(sb_conv))
print("s_dp_conv[pth] len=",len(s_dp_conv[0]), "kernel len= ",len(kernel))

####################################
### Down sampled signal + kernel ###
####################################

# down sample signal by splitting into 'N_paths' seperate paths
s_ds = s.down_sample_split_path(d_bpsk, N_paths_ds)

# create down-sampled kernel bpfilter from fitler object
k_ds, k_ds_t = f2.digitals_bp_filt(center_freq,BW,Ns_dk,(sample_rate/N_paths_ds))
k_ds = k_ds * N_paths_ds
Ndk = len(k_ds)

# convolve broken-unpacked signals with kernel
s_ds_conv = list()
for i in range(N_paths_ds):
  s_ds_conv.append(list(np.convolve(s_ds[i],k_ds)))

# length of convolution between down-sampled signal / kernel
conv_ds_len = Nds + Ndk - 1
bpsk_ds_time_range = bpsk_time_range/ N_paths_ds
conv_ds_time_range = (bpsk_time_range+kernel_time_range)/N_paths_ds
kernel_ds_time_range = kernel_time_range/ N_paths_ds

# time arrays for down-sampled signal / down-sampled convolution
bpsk_ds_time = np.linspace(0,bpsk_ds_time_range, Nds)
conv_ds_time = np.linspace(0,conv_ds_time_range,conv_ds_len)
kernel_ds_time = np.linspace(0,kernel_ds_time_range,Ndk)

#####################
### Recombination ###
#####################

print("kn len:",len(k_ds)," sa_ds len:",len(s_ds[0])," sa_ds_conv len:",len(s_ds_conv[0]))
print("Nds: ",Nds,"Ndk: ",Ndk)

ds_conv_alt = s.multi_lane_conv_recon(N_paths_ds, conv_len, conv_ds_len, s_ds_conv)

#############
### FFT's ###
#############

## Take FFT of our bandpass filter
## scale frequency axis by sample rate
kernel_ft = np.abs(np.fft.fft(kernel))
kernel_freq = f1.BP_SR * np.fft.fftfreq(kernel_ft.size)

## Take FFT of the downsampled filter kernel
## scale frequency axis by sample rate
kds_ft = np.abs(np.fft.fft(k_ds))
kds_freq = f2.BP_SR * np.fft.fftfreq(kds_ft.size)

## Take FFT of the reconstructed signal 
recon_ft = np.abs(np.fft.fft(ds_conv_alt))
recon_freq = sample_rate * np.fft.fftfreq(ds_conv_alt.size)

## FFT of BPSK
bpsk_ft = np.abs(np.fft.fft(d_bpsk))
bpsk_freq = sample_rate * np.fft.fftfreq(d_bpsk.size)

## FFT of bpsk/ filter convolution
conv_ft = np.abs(np.fft.fft(conv))
conv_freq = sample_rate * np.fft.fftfreq(conv.size)

############################
### gen formatted kernel ###
############################
## kernel scaling
Nd = 15
Ndy = 27
M = pow(2, Ndy) - 1      ## scaling factor for kernel values

print("Down-sampled Kernel:")
print(k_ds)

## format kernel data for vhdl testing
k_ds_format = ft.format_kernel_values(k_ds, M)

## generate test data file
ft.gen_format_kernel_data("output_files/conv_filter_def.txt", k_ds_format)

################
### Plotting ###
################

Nrows = int(N_paths_ds/2)
Ncolumns = int(N_paths_ds/ Nrows)
color = ["b.","r.","g.","m.","b.","r.","g.","m."]

if(PLT_SIGNAL):
  ## Figure 1
  plt.figure(1,figsize=(8, 8))
  ## single convolution
  plt.subplot(3,1,1)
  plt.title("bpsk signal")
  plt.plot(d_bpsk_t[0:PLT_RANGE], d_bpsk[0:PLT_RANGE], 'b')
  plt.xlabel("time(s)")

  ## kernel
  plt.subplot(3,1,2)
  plt.title("kernel")
  plt.plot(kernel_time, kernel,'r')
  plt.xlabel("time(s)")

  ## conv result
  plt.subplot(3,1,3)
  plt.title("bpsk signal ** kernel")
  plt.plot(conv_time[0:PLT_RANGE],conv[0:PLT_RANGE],'g')
  plt.xlabel("time(s)")

if(PLT_DS_PADDED):
  ## Figure 2
  plt.figure(2,figsize=(8, 8))
  ## down-sampled-padded signals
  for i in range(N_paths_ds):
    plt.subplot(Nrows,Ncolumns,i+1)
    plt.plot(d_bpsk_t[0:PLT_RANGE],s_dp[i][0:PLT_RANGE],color[i])

if(PLT_DS_PADDED_CONV):
  ## Figure 3
  plt.figure(3,figsize=(8, 8))
  ## Down-sampled padded signal convolution result
  for i in range(N_paths_ds):
    plt.subplot(Nrows,Ncolumns,i+1)
    plt.plot(kernel_ds_time[0:PLT_RANGE],s_ds[i][0:PLT_RANGE],color[i])

if(PLT_DS_CONV_KERNEL):
  ## Figure 4
  plt.figure(4,figsize=(8, 8))
  ## down-sampled signal ** down-sampled kernel"
  for i in range(N_paths_ds):
    plt.subplot(Nrows,Ncolumns,i+1)
    plt.plot(conv_ds_time[0:PLT_RANGE],s_ds_conv[i][0:PLT_RANGE],color[i])

if(PLT_STD_FREQ):
  ## Figure 5
  plt.figure(5,figsize=(8, 8))
  ## BPSK freq
  plt.subplot(3,1,1)
  plt.title("bpsk signal (freq)")
  plt.plot(bpsk_freq, bpsk_ft.real, 'b')
  plt.xlabel("freq (Hz)")

  ## kernel freq
  plt.subplot(3,1,2)
  plt.title("kernel (freq)")
  plt.plot(kernel_freq, kernel_ft.real,'r.')
  plt.xlabel("freq (Hz)")

  ## conv result
  plt.subplot(3,1,3)
  plt.title("bpsk ** kernel")
  plt.plot(conv_freq, conv_ft.real,'g')
  plt.xlabel("freq (Hz)")

if(PLT_DS_TIME):
  ### Figure 6
  plt.figure(6,figsize=(8,8))
  ## bandpass filter iFFT
  plt.subplot(2,1,1) 
  plt.title("bandpass filter (time response)")
  plt.plot(k_ds_t, k_ds, 'b')
  plt.xlabel("time(s)")
  plt.ticklabel_format(axis='x', style='sci', scilimits=(0,0))

  ## bandpass filter real
  plt.subplot(2,1,2)  
  plt.title("bandpass filter (freq response)")
  plt.plot(kds_freq, kds_ft, 'k.')
  plt.xlabel("frequency(Hz)")
  plt.ticklabel_format(axis='x', style='sci', scilimits=(0,0))

if(PLT_RECON):
  ### Figure 7
  plt.figure(7,figsize=(8,8))
  ## reconstructed convolution result time
  plt.subplot(2,1,1) 
  plt.title("reconstruction (time response)")
  plt.plot(conv_time[0:PLT_RANGE], ds_conv_alt[0:PLT_RANGE], 'b')
  plt.xlabel("time(s)")
  plt.ticklabel_format(axis='x', style='sci', scilimits=(0,0))

  ## reconstructed convolution result freq
  plt.subplot(2,1,2) 
  plt.title("reconstruction (freq response)")
  plt.plot(recon_freq, recon_ft.real, 'g')
  plt.xlabel("freq (Hz)")
  plt.ticklabel_format(axis='x', style='sci', scilimits=(0,0))

plt.show()