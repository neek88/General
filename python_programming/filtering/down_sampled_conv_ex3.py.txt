import matplotlib.pyplot as plt
import numpy as np
import math as m
from scipy import signal 
from modules import BPSKGen
from modules import SigUtil
from modules import FilterGen
from modules import FiltUtil

# useful objects
PI = np.pi
s = SigUtil.SigUtil()
b = BPSKGen.BPSKGen()
f = FilterGen.FilterGen()

DS_CONV=1
DS_PAD=0
DS_PAD_CONV=0

######## Control Params
## signal parameters
f0 = 50
T0 = 1/ f0
N_periods = 8                         ## total number of periods of waveform
N_paths = 8                           ## number of paths (Ns/ Npaths must be an integer)
Ns = 2048                              ## Must be divisible by N_paths

## Filter parameters
filter_bw = 1e3
Nk = 256

########  Calculated Parameters
sample_factor = int(Ns/ N_periods)    ## number of samples per period
sample_rate = f0 * sample_factor      ## number of samples per second
#Nk = sample_factor                    ## total number of samples for the filter kernel
Nds = int(Ns/N_paths)                 ## samples in down-sampled signal
Ndk = int(Nk/N_paths)                 ## samples in down-sampled kernel

######## Signal Creation
## sinusoidal signal
signal_time_range = T0 * N_periods
time = np.linspace(0, T0*N_periods, Ns)
sig_phase_arg = 2 * PI * f0 * time
input_signal = np.sin(sig_phase_arg) + (1/3)*np.sin(3*sig_phase_arg) + (1/5)*np.sin(5*sig_phase_arg) + (1/7)*np.sin(7*sig_phase_arg)

# create Low-Pass filter
kernel = signal.firwin(Nk, filter_bw, window="blackman", fs=sample_rate)
kernel_time_range = Nk * (1/sample_rate)
kernel_time = np.linspace(0, kernel_time_range, Nk)

## Length of convolution between signal & kernel
conv_len = Ns + Nk - 1
conv_time_range = signal_time_range + kernel_time_range

# convolve signal with kernel
conv_time = np.linspace(0, conv_time_range, conv_len)
conv = np.convolve(input_signal, kernel)

######## Down sampled signal & kernel (padded with zeros)
# down-sampled-padded signals
s_dsp = []
for i in range(N_paths): 
  s_dsp.append(list(np.zeros(Ns)))

# populate down-sampled signal arrays
for path in range(N_paths):
  for idx in range(len(input_signal)):
    if(idx % N_paths == path): s_dsp[path][idx] = input_signal[idx]

# convolve down-sampled signals with kernel
s_dsp_conv = []
for path in range(N_paths):
  s_dsp_conv.append(list(np.convolve(s_dsp[path], kernel)))

# rebuild convolution output array
sb_conv = np.zeros(conv_len)
for path in range(N_paths):
  sb_conv = sb_conv + np.array(s_dsp_conv[path])

print("Standard-parameters:")
print("conv_len= ", conv_len, "sb_conv len=", len(sb_conv))
print("s_dsp_conv[path] len=", len(s_dsp_conv[0]), "kernel len= ", Nk)
print("\n")

######## Down sampled signal + kernel
# down sample signal by splitting into 'N_paths' seperate paths
s_ds = []
for path in range(N_paths):
  s_ds.append(input_signal[path::N_paths])
s_ds = np.array(s_ds)

# down sample kernel by factor of N_paths
k_ds = kernel[0::N_paths]
Ndk = len(k_ds)
# convolve down-sampled signals with down-sampled kernel
s_ds_conv = list()
for path in range(N_paths):
  # s_ds_conv.append(list(np.convolve(s_ds[path], kernel[path::N_paths])))
  s_ds_conv.append(list(np.convolve(s_ds[path], k_ds)))

# length of convolution between down-sampled signal / kernel
ds_conv_len = Nds + Ndk - 1
ds_signal_time_range = signal_time_range / N_paths
ds_conv_time_range = (signal_time_range + kernel_time_range) / N_paths
ds_kernel_time_range = kernel_time_range / N_paths

# time arrays for down-sampled signal & kernel & convolution
ds_signal_time = np.linspace(0, ds_signal_time_range, Nds)
ds_kernel_time = np.linspace(0, ds_kernel_time_range, Ndk)
ds_conv_time = np.linspace(0, ds_conv_time_range, ds_conv_len)

print("Down-sampled parameters:")
print("ds-kernel len:", len(k_ds)," ds-signal len:",len(s_ds[0])," ds-conv len:",len(s_ds_conv[0]))
print("Nds: ", Nds, "Ndk: ", Ndk)
print("\n")

# # recombine
# ds_conv_alt = s.multi_lane_conv_recon(N_paths, conv_len, ds_conv_len, s_ds_conv)

# print("Comparing down-sampled algorithm to direct conv")
# print("ds_conv_alt: ", ds_conv_alt[100:120])
# print("conv: ", conv[100:120])

ds_conv_alt = np.zeros(conv_len+1)
ds_conv_alt_time = np.linspace(0, conv_time_range, conv_len+1)
prev_val = 0
Np = N_paths
for i in range(Nds + Ndk):
  if(i == 0):                   ## ramp up
    for path in range(N_paths):
      ds_conv_alt[i+path] = prev_val + s_ds_conv[path][i]
      prev_val = ds_conv_alt[i+path]
  elif(i < ds_conv_len):        ## center
    for path in range(N_paths):
      ds_conv_alt[Np*i+path] = -s_ds_conv[path][i-1] + s_ds_conv[path][i] + ds_conv_alt[Np*i+(path-1)]
      #prev_val = ds_conv_alt[Np*i+path]
  else:                         ## ramp down
    for path in range(N_paths):
      # print("path: ", path, " i: ", i, " Np*i+path: ", Np*i+path)
      ds_conv_alt[Np*i+path] = -s_ds_conv[path][i-1] + ds_conv_alt[Np*i+(path-1)]
      #prev_val = ds_conv_alt[Np*i+path]

######## Plotting
Nrows = int(N_paths/2)
Ncolumns = int(N_paths/ Nrows)
color_dot = ["b.","r.","g.","m.","b.","r.","g.","m."]
color = ["b","r","g","m","b","r","g","m"]

## Figure 1
fig_1, axes_1 = plt.subplots(3,1,figsize=(8, 8))
fig_1.suptitle("Full-Rate Signal/ Kernel/ Convolution")
axes_1[0].plot(time, input_signal, 'b.')
axes_1[1].plot(kernel_time, kernel, 'r')
axes_1[2].plot(conv_time, conv, 'g')

## Figure 2
if(DS_PAD):
  fig_2, axes_2 = plt.subplots(Nrows,Ncolumns,figsize=(8, 8))
  fig_2.suptitle("Down-sampled-padded signals")
  for row in range(Nrows):
    for col in range(Ncolumns):
      axes_2[row][col].plot(time, s_dsp[row*Ncolumns+col], color_dot[row*Ncolumns+col])
if(DS_PAD_CONV):
  ## Figure 3
  fig_3, axes_3 = plt.subplots(Nrows,Ncolumns,figsize=(8, 8))
  fig_3.suptitle("Down-sampled-padded convolution")
  for row in range(Nrows):
    for col in range(Ncolumns):
      axes_3[row][col].plot(ds_signal_time, s_ds[row*Ncolumns+col], color[row*Ncolumns+col])

if(DS_CONV):
  ## Figure 4
  fig_4, axes_4 = plt.subplots(Nrows,Ncolumns,figsize=(8, 8))
  fig_4.suptitle("Down-sampled-signal ** down-sampled-kernel")
  for row in range(Nrows):
    for col in range(Ncolumns):
      axes_4[row][col].plot(ds_conv_time, s_ds_conv[row*Ncolumns+col], color[row*Ncolumns+col])

## Figure 5
fig_5, axes_5 = plt.subplots(3,1,figsize=(8, 8))
fig_5.suptitle("convolution + recon-conv & down-sampled kernel ")
axes_5[0].plot(ds_conv_alt_time, ds_conv_alt, 'm')
axes_5[1].plot(conv_time, conv, 'k.')
axes_5[2].plot(ds_kernel_time, k_ds, 'g')

plt.show()

# for i in range(conv_len):
#   print("conv: ", conv[i], "ds_conv_alt: ", ds_conv_alt[i])